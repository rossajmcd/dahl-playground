(ns kitchen.api
  (:require [protean.api.transformation.sim :refer :all]))

(def node-atom (atom :Ready))

(def graph
  {:Ready {:make-tea :MakingTea
           :make-coffee :MakingCoffee}
   :MakingTea {:get-status :GettingTeaStatus?}
   :MakingCoffee {:get-status :GettingCoffeeStatus?}
   :GettingTeaStatus? {:making-tea :MakingTea
                       :completing-tea :MadeTea
                       :erroring-tea :ErroredTea}
   :GettingCoffeeStatus? {:making-coffee :MakingCoffee
                          :completing-coffee :MadeCoffee
                          :erroring-coffee :ErroredCoffe}})

(def tea-ready (atom false))
(def coffee-ready (atom false))

(def rules
  {:MakingTea #(future (Thread/sleep 30000) (reset! tea-ready true))
   :GettingTeaStatus? #(if @tea-ready :MadeTea :MakingTea)
   :MakingCoffee #(future (Thread/sleep 30000) (reset! coffee-ready true))
   :GettingCoffeeStatus? #(if @coffee-ready :MadeCoffee :MakingCoffee)})

(defn next-node
  [graph node edge]
  (let [n (get-in graph [node (keyword edge)])
        f (when-let [rule (get rules n)] (apply rule []))]
    (cond
      (keyword? f) f
      (future? f)  n
      :else        n)))

(defn result
  [graph node]
  {:node node
   :_links (into {} (for [edge (keys (node graph))]
     {edge {:method "post"
            :href "/api/kitchen/ec0e7fbc-a99d-4dd2-bea3-716bd6e2fe2c"
            :body (str "{\"event\": \"" (name edge) "\"}")}}))})

{
  "api" {
    "kitchen" {
      :get #(respond % 200 (result graph @node-atom))
    }
    "kitchen/${uuid}" {
      :post #(if-let [n (next-node graph @node-atom (body-param % "event"))]
              (do (reset! node-atom n)
                  (respond % 200 (result graph n)))
              (respond % 400 (result graph @node-atom)))
    }
  }
}
