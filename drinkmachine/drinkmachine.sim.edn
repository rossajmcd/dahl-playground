(ns drinkmachine.api
  (:require [clojure.string :as str]
            [protean.api.transformation.sim :refer :all]))

(def atom-nodes (atom [{:Ready nil}]))

(def atom-edges (atom nil))

(defn current-node-key
  [nodes]
  (first (keys (last nodes))))

(defn next-node-key
  [graph node-key edge]
  (get-in graph [node-key edge]))

(defn update-node
  [a b]
  (let [[k v] (first b)]
    (if-let [idx (some #(when (get % k) (.indexOf a %)) a)]
      (update-in a [idx k] merge v)
      (conj a b))))

(def graph
  {:Ready {:select-ingredients :Ingredients}
   :Ingredients {:add-beverage-required :Ingredients
                 :add-milk :Ingredients
                 :add-sugar :Ingredients
                 :make-drink :MakingDrink}
   :MakingDrink {:shutdown :ShutDown
                 :complete-machine :MadeDrink}
   :MadeDrink {:shutdown :ShutDown}
   :Shutdown {}})

(def rules
  {:MakingDrink #(future
                   (Thread/sleep 10000)
                   (when (= (current-node-key @atom-nodes) :MakingDrink)
                     (swap! atom-nodes update-node {:MadeDrink nil})))
   :Ingredients #(do
                   {:Ingredients (dissoc
                     (get graph :Ingredients)
                     (when-not (get-in (last @atom-nodes) [:Ingredients :beverage]) :make-drink))})})

(def bodies
  {:Ingredients {:add-beverage-required {:beverage #{"tea" "coffee"}}
                 :add-milk {:milk #{"none" "semi" "full"}}
                 :add-sugar {:sugar #{0 1 2}}}})

(defn apply-rule
  [graph node-key rules]
  (let [r (when-let [rule (get rules node-key)] (apply rule []))]
    (cond
      (nil? node-key) node-key
      (map? r)        r
      (future? r)     {node-key (get graph node-key)}
      :else           {node-key (get graph node-key)})))

(defn result
  [graph node-key bodies]
  (let [result (apply-rule graph node-key rules)
        all (flatten (map keys (vals result)))
        edges (remove #(or (nil? %) (str/includes? (name %) "-machine")) all)]
    (reset! atom-edges (into {} (for [edge edges] {edge (str (java.util.UUID/randomUUID))})))
    {:resource "drinkmachine"
     :states @atom-nodes
     :controls (into {} (for [edge edges]
       {edge {:method "post"
              :href (str "/api/drinkmachine/" (get @atom-edges edge))
              :body (when-let [b (get-in bodies [node-key edge])]
                      (clojure.data.json/write-str b))}}))}))
{
  "api" {
    "drinkmachine" {
      :get #(respond % 200 (result graph (current-node-key @atom-nodes) bodies))
    }
    "drinkmachine/${uuid}" {
      :post (fn [req]
        (let [uuid (path-param req "uuid")
              edge (get (clojure.set/map-invert @atom-edges) uuid)
              curr-n (current-node-key @atom-nodes)
              errors (->> (get-in bodies [curr-n edge])
                          (remove (fn [[k vs]] (.contains vs (body-param req (name k)))))
                          (map (fn [[k vs]] (str (name k) ": '" (body-param req (name k)) "' does not match one of: [" (str/join ", " vs) "]")))
                          seq)]
          (cond
            (nil? edge) (respond req 404 (assoc (result graph curr-n bodies) :errors [(str "uuid: '" uuid "' does not match one of: [" (str/join ", " (vals @atom-edges)) "]")]))
            errors      (respond req 400 (assoc (result graph curr-n bodies) :errors errors))
            :else       (let [next-n (next-node-key graph curr-n edge)
                              data {next-n (body-clj req true)}]
                           (swap! atom-nodes update-node data)
                           (respond req 200 (result graph next-n bodies))))))
    }
  }
}
